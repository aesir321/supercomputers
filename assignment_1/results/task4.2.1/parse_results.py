#!/usr/bin/python
import os 
from os.path import isfile, join
import sys

class result_parser:
    results_directory = 'data/task4.2.1'
    
    def __init__(self):
        self.results_files = sys.argv[1].split()
        self.results_file = 'results_'
        self.times = []
        self.baseline = None
        self.speedups = {}
        self.speedup = []
        
    def parse_results(self):
        """
        Takes a list of results files, extracts the time and compiler flags and writes a new file containing
        the time in seconds, and the compiler flags used to achieve the time.  The newly written results file
        has a name of the following format:

        results_file1_file2_..._filen.dat
        """
        for rf in self.results_files:
            self.results_file += rf.replace('.out', '_')

            with open(join(self.results_directory, rf), 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if 'Elapsed time' in line:
                        self.times.append(line.replace(' ', '').split('=')[-1].replace('(s)',''))
        
        self.results_file += '.dat'
        self.results_file = self.results_file.replace('_.', '.')
        self.baseline = float(self.times[0]) #No flag binary is always run first
        binaries = []

        with open(join(self.results_directory, 'binaries.key'), 'r') as f:
            lines = f.readlines()
            [binaries.append(line) for line in lines]

        with open(join(self.results_directory, self.results_file), 'w') as f:
            for i, j in zip(binaries, self.times):
                f.write(str(i).replace('\n', '') + ',' + str(j))
                
    def get_key(self, item):
        return item[-1]

    def write_ordered_runtime_file(self):
        """
        Takes the results file generated by parse_results() and orders it from fastest to slowest
        overwriting the initially unorderd file.
        """

        data = []

        with open(join(self.results_directory, self.results_file), 'r+') as f:
            lines = f.readlines()
            [data.append(line.split(',')) for line in lines]
            data.sort(key=self.get_key)
            f.seek(0)
            f.write('time / s, flags, speedup\n')
            [f.write(d[-1].replace('\n', '') + ',' + d[0] + ',' + str(self.compute_speedup(float(d[-1]))) + '\n') for d in data]
            f.truncate()

    def compute_speedup(self, runtime):
        return self.baseline - runtime
    
    def run(self):
        self.parse_results()
        self.write_ordered_runtime_file()

    def calculate_speedup_table(self):
        result_directories = ['gcc/hw/results/',
                              'gcc/sb/results/',
                              'intel/hw/results/',
                              'intel/sb/results/']
        optimised_flags = []
        fastest_binary = ['100000']
        fb_loc = ''
        
        for result in result_directories:
            rd = join(self.results_directory, result)
            files = [f for f in os.listdir(rd) if os.path.isfile(join(rd, f))]
            
            for i, fi in enumerate(files):
                with open(join(rd, fi), 'r') as f:
                    lines = f.readlines()
                    lines.pop(0) # Not interested in headings
                    
                    for line in lines:
                        line = line.split(',')
                        if float(line[0]) < float(fastest_binary[0]):
                            fastest_binary = line
                            fb_loc = rd

                        flags = line[1]
                        speedup = float(line[-1])
                        if i == 0:
                            self.speedups[flags] = speedup
                        else:
                            self.speedups[flags] += speedup

            for key, value in self.speedups.iteritems():
                avg_speedup = value / 2. # Two sets of results for now
                self.speedups[key] = avg_speedup
            
            with open(join(rd, 'speedups.dat'), 'w') as f:
                for i, sorted_speedups in enumerate(sorted(self.speedups.items(), key=lambda x:x[1], reverse=True)):
                    if i == 0:
                        optimised_flags.append(sorted_speedups[0].split('_')[-1])
                    f.write(sorted_speedups[0] + ',' + str(sorted_speedups[1]) + '\n')

        for r, f in zip(result_directories, optimised_flags):
            self.write_makefile(join(join(self.results_directory, r), 'Makefile'), f)

        print 'The fastest combination was: ' + str(fastest_binary) + fb_loc
                    
    def write_makefile(self, results_directory, flags):
        makefile_temp = 'lulesh2.0/Makefile'
        lines = []
        with open(makefile_temp, 'r') as f:
            lines = f.readlines()

        with open(results_directory, 'w') as f:
            for line in lines:
                if line.startswith('SERCXX ='):
                    if 'gcc' in results_directory:
                        f.write('SERCXX = g++ -DUSE_MPI=0\n')
                    else:
                        f.write('SERCXX = icc -DUSE_MPI=0\n')
                elif line.startswith('CXXFLAGS = '):
                    f.write('CXXFLAGS = -O3 -I. -w ' + flags + '\n')
                else:
                    f.write(line)
        print 'Wrote Makefile to ' + results_directory
                        
            
rp = result_parser()
#rp.run()
rp.calculate_speedup_table()
